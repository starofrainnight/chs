<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>StarOfRainNight's Home</title><link href="https://starofrainnight.github.io/cht/" rel="alternate"></link><link href="https://starofrainnight.github.io/cht/feeds/all.atom.xml" rel="self"></link><id>https://starofrainnight.github.io/cht/</id><updated>2016-03-21T20:47:00+08:00</updated><entry><title>沒有改變世界的夢想，哪裏有偉大的項目？</title><link href="https://starofrainnight.github.io/cht/mei-you-gai-bian-shi-jie-de-meng-xiang-na-li-you-wei-da-de-xiang-mu.html" rel="alternate"></link><updated>2016-03-21T20:47:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2016-03-21:cht/mei-you-gai-bian-shi-jie-de-meng-xiang-na-li-you-wei-da-de-xiang-mu.html</id><summary type="html"></summary></entry><entry><title>重寫博客</title><link href="https://starofrainnight.github.io/cht/zhong-xie-bo-ke.html" rel="alternate"></link><updated>2016-02-13T10:17:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2016-02-13:cht/zhong-xie-bo-ke.html</id><summary type="html">&lt;p&gt;很久沒寫博客了，上一次寫博客已經是2012年的事情了。在這些年以來，諸事繁忙，加之 blogspot 的編輯器並不便於編寫，而且在 blogspot 上編寫博客也不便於整理自己的文章及進行版本管理。&lt;/p&gt;
&lt;p&gt;幾年過去，隨着技術的發展，基於 github 等源代碼管理工具之上的靜態博客也出現了，發現這類型靜態博客非常便於編寫及進行版本管理，重燃起編寫博客的興趣。&lt;/p&gt;
&lt;p&gt;經過比較，最後選擇了 pelican 作爲我的靜態博客的生成及管理工具。&lt;/p&gt;
&lt;p&gt;接下來，慢慢把我原來博客的內容遷移過來。&lt;/p&gt;
</summary></entry><entry><title>ubifs 應用案例</title><link href="https://starofrainnight.github.io/cht/ubifs-ying-yong-an-li.html" rel="alternate"></link><updated>2012-10-11T11:37:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2012-10-11:cht/ubifs-ying-yong-an-li.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;環境&lt;/h2&gt;
&lt;p&gt;CPU : Freescale MX27&lt;/p&gt;
&lt;p&gt;NAND FLASH : Samsung K9F2G08U0B, 2Gbits = 256MB&lt;/p&gt;
&lt;p&gt;操作系統: linux&lt;/p&gt;
&lt;p&gt;內核版本: 2.6.27&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux"&gt;
&lt;h2&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;linux 編譯選項&lt;/h2&gt;
&lt;div class="section" id="ubi"&gt;
&lt;h3&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;支持UBI&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
Device Drivers  ---&amp;gt;
&amp;lt;*&amp;gt; Memory Technology Device (MTD) support  ---&amp;gt;
    [*]   MTD partitioning support
    &amp;lt;*&amp;gt;   NAND Device Support  ---&amp;gt;
    UBI - Unsorted block images  ---&amp;gt;
        &amp;lt;*&amp;gt; Enable UBI
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ubifs"&gt;
&lt;h3&gt;2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;支持UBIFS 文件系統&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
File systems  ---&amp;gt;
Miscellaneous filesystems  ---&amp;gt;
    &amp;lt;*&amp;gt; UBIFS file system support
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;linux 啟動命令行參數&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
noinitrd console=ttymxc0,115200 ubi.mtd=2 root=ubi0:rootfs rootfstype=ubifs rw ip=off init=/linuxrc video=imx-fb:Innolux-WVGA
&lt;/pre&gt;
&lt;p&gt;我們的flash 在內核裡被分為三個 mtd 區: bootloader, kernel, filesystem. 因此 ubi.mtd=2, 即選中第三個 mtd 分區作為 ubifs 根分區. 至於 ubi0:rootfs 則跟創建文件系統鏡像時的 *.cfg 有關.&lt;/p&gt;
&lt;p&gt;需要注意的是, 很多 bootloader 會覆蓋 linux 本身的默認命令行參數, 所以, 如果存在這樣的 bootloader 就必須修改 bootloader 調用 linux 時的命令行參數! 否則 ubifs 完全不起作用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;創建 ubifs 文件系統鏡像&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
mkfs.ubifs -m 2048 -e 129024 -c 992 -r filesystem_base filesystem_base.ubifs
&lt;/pre&gt;
&lt;p&gt;ubifs 文件系統鏡像不能直接寫入 flash, 需要再根據這個生成的 ubifs 格式的文件系統鏡像生成 ubi 鏡像才能直接寫入 flash .&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;參數 &amp;quot;-m&amp;quot;&lt;/dt&gt;
&lt;dd&gt;為 flash 分頁大小, 可從 nand flash 的 datasheet 得知. 有些 flash 的分頁會有附加空間, 如我們所使用的這個 flash 每個分頁就帶有 64 字節的附加空間(1), 附加空間不計入我們的 -m 參數中!&lt;/dd&gt;
&lt;dt&gt;參數 &amp;quot;-e&amp;quot;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;把 128KiB 減去一個分頁(2048)大小, 則等於 129024. 如果加載 ubifs 出現類似以下的錯誤:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UBIFS error (pid 1): validate_sb: LEB size mismatch: 131072 in superblock, 129024 real
&lt;/pre&gt;
&lt;p class="last"&gt;則以那個 real 值為準!&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;參數 &amp;quot;-c&amp;quot;&lt;/dt&gt;
&lt;dd&gt;最大邏輯刷寫塊數量, 似乎可以是任意數值, 只要不超過邏輯塊總數即可.&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;5&amp;nbsp;&amp;nbsp;&amp;nbsp;創建 ubi 鏡像&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
ubinize -o ubi.img -m 2048 -p 128KiB -s 512 -O 512 ubiimage.cfg
&lt;/pre&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;參數 &amp;quot;-m&amp;quot;&lt;/dt&gt;
&lt;dd&gt;參考 4. 中的 &amp;quot;-m&amp;quot; 參數&lt;/dd&gt;
&lt;dt&gt;參數 &amp;quot;-p&amp;quot;&lt;/dt&gt;
&lt;dd&gt;為一次性擦除塊的大小, 可從 nand flash 的 datasheet 得知. 附加空間不計在內.&lt;/dd&gt;
&lt;dt&gt;參數 &amp;quot;-s&amp;quot;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;與 -O 必須一致, 分頁子頁大小, 似乎跟 flash 的分頁組成有關, 似乎我們所用的 flash 每一頁由4 個子分頁組成, 一個子分頁為 512. 當出現以下錯誤時:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UBI error: validate_ec_hdr: bad VID header offset 2048, expected 512.
&lt;/pre&gt;
&lt;p class="last"&gt;則以 expected 值為準.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;其中 ubiimage.cfg 內容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[ubifs]
mode=ubi
image=filesystem_base.ubifs
vol_id=0
vol_size=100MiB
vol_type=dynamic
vol_name=rootfs
vol_flags=autoresize
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;6&amp;nbsp;&amp;nbsp;&amp;nbsp;燒寫並啟動&lt;/h2&gt;
&lt;p&gt;把 5. 裡生成的 ubi.img 燒寫進板子, 啟動, 當出現類似以下信息時表示, ubifs 已經成功加載:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UBI: attaching mtd2 to ubi0
UBI: physical eraseblock size:   131072 bytes (128 KiB)
UBI: logical eraseblock size:    129024 bytes
UBI: smallest flash I/O unit:    2048
UBI: sub-page size:              512
UBI: VID header offset:          512 (aligned 512)
UBI: data offset:                2048
UBI: attached mtd2 to ubi0
UBI: MTD device name:            &amp;quot;nand.rootfs&amp;quot;
UBI: MTD device size:            123 MiB
UBI: number of good PEBs:        985
UBI: number of bad PEBs:         6
UBI: max. allowed volumes:       128
UBI: wear-leveling threshold:    4096
UBI: number of internal volumes: 1
UBI: number of user volumes:     1
UBI: available PEBs:             0
UBI: total number of reserved PEBs: 985
UBI: number of PEBs reserved for bad PEB handling: 9
UBI: max/mean erase counter: 1/0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;7&amp;nbsp;&amp;nbsp;&amp;nbsp;註釋&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;附加空間可以使用也可以不用, 一般用於存儲文件系統的附帶信息.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;8&amp;nbsp;&amp;nbsp;&amp;nbsp;錯誤信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;UBIFS error (pid 1): validate_sb: LEB size mismatch: 131072 in superblock, 129024 real&lt;/p&gt;
&lt;p&gt;參考 4. 參數 &amp;quot;-e&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;UBI error: validate_ec_hdr: bad VID header offset 2048, expected 512.&lt;/p&gt;
&lt;p&gt;參考 5. 參數 &amp;quot;-s&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;UBI warning: ubi_io_read_ec_hdr: no EC header found at PEB 845, only 0xFF bytes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
可忽略, 剛刷寫完的, 很多這種提示.&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;VFS: Cannot open root device &amp;quot;ubi0:rootfs&amp;quot; or unknown-block(0,0 ...&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
mtd分區不是 ubi 格式 或者 創建 ubi 鏡像時的 cfg 文件有誤.&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="ubifs"></category><category term="freescale"></category><category term="mx27"></category></entry><entry><title>UDP下嘅實時音視頻傳輸機制</title><link href="https://starofrainnight.github.io/cht/udpxia-kai-shi-shi-yin-shi-pin-chuan-shu-ji-zhi.html" rel="alternate"></link><updated>2010-01-31T20:53:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2010-01-31:cht/udpxia-kai-shi-shi-yin-shi-pin-chuan-shu-ji-zhi.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;經歷咗一兩年係項目當中嘅實時音視頻實踐, 覺得要實現好嘅實時音視頻傳輸實屬不易. 以下呢套UDP下嘅實現流程, 係血嘅經驗, 每一點都是來之不易.&lt;/p&gt;
&lt;p&gt;全局要點: 視頻可跳, 但聲音不斷.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;發送方&lt;/h2&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;開始時, 編碼I幀, 發送&lt;/li&gt;
&lt;li&gt;接著, 發P幀 ( 聲音與視頻編碼是不同的, 每次真實發送幀前, 讀取錄音緩沖區, 並打包 ), 發N個P幀後, 跳到 a&lt;/li&gt;
&lt;li&gt;如果在發P幀過程中, 接收到對方發來的 &amp;quot;重發I 幀&amp;quot; 請求, 馬上放棄目前所編碼的幀(視頻幀,不是聲音幀), 跳轉到 a&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;接收方&lt;/h2&gt;
&lt;ol class="loweralpha simple"&gt;
&lt;li&gt;建立幀列表, 至少存儲3幀以上才開始播放, 使用順序插入法, 尋找相應幀序號的位置, 並插入.&lt;/li&gt;
&lt;li&gt;播放開始時, 不停從幀列表中取得一幀(由於此時幀列表是順序的,故此取列表頭的那一幀即可), 如果是P幀時則放棄, 直到找到I幀才開始真正播放. 聲音幀不需要等I幀, 只要按著順序播放即可.&lt;/li&gt;
&lt;li&gt;播放過程中, 不停從幀列表中取得一幀進行播放( 聲音播放與視頻播放線程需要分開!!切記! )&lt;/li&gt;
&lt;li&gt;當視頻播放線程發現聲音播放的幀號大於正要播放的視頻2幀以上時, 馬上放棄當前播放的視頻, 並請求對方 &amp;quot;重發I幀&amp;quot;, 並一直讀取到幀緩沖列表中大於等於音頻幀號的視頻 &amp;quot;I&amp;quot; 幀為止, 再播放 ( 此處是解決音視頻不同步的情況, 即視頻慢於音頻並隨時間累積 )&lt;/li&gt;
&lt;li&gt;如果在 c 當中, 發現掉幀了( 要播放的幀號不等於上一次播放的幀號 +1 ), 請求對方 &amp;quot;重發I幀&amp;quot;, 並等待下一個 &amp;quot;I幀&amp;quot; (針對的是視頻幀, 音頻幀只要是大於上一次播放的幀號即可以播放 )&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;p&gt;上面缺了任何一點, 都會導致播放出現問題！&lt;/p&gt;
&lt;/div&gt;
</summary><category term="network"></category><category term="sip"></category><category term="rtp"></category></entry><entry><title>班得瑞(Bandari)</title><link href="https://starofrainnight.github.io/cht/ban-de-rui-bandari.html" rel="alternate"></link><updated>2010-01-21T21:18:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2010-01-21:cht/ban-de-rui-bandari.html</id><summary type="html">&lt;p&gt;最近先至發現原來有十幾首好好聽嘅歌，原來喺屬於 Bandari 兩個專輯嘅音樂。再搜索咗一下呢個樂隊嘅信息，好似幾有意思甘，似乎眾說紛紜，有人話呢個樂隊係假嘅，亦有人話呢個樂隊衹係平時好低調，仲有人話 Bandari 係瑞士唱片公司 Audio Video Communications AG（簡稱AVC）嘅產品，似乎最後一種講法比較靠譜，上他們的主頁可以揾到 Bandari 嘅專輯。&lt;/p&gt;
&lt;p&gt;似乎 Bandari 華人區更受歡迎，試下係Google搜索一下就知道，如果查英文，基本揾唔到真正同 Bandari 專輯有關嘅信息，但搜索中文網頁就一大堆。&lt;/p&gt;
&lt;p&gt;但無關系啦，只要好聽就得~~話知佢係假定系真啦~~&lt;/p&gt;
</summary></entry><entry><title>終於可以用Google音樂下載啦~~</title><link href="https://starofrainnight.github.io/cht/zhong-yu-ke-yi-yong-googleyin-le-xia-zai-la.html" rel="alternate"></link><updated>2009-04-09T12:22:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2009-04-09:cht/zhong-yu-ke-yi-yong-googleyin-le-xia-zai-la.html</id><summary type="html">&lt;p&gt;前一排，聽講Google可以免費下載正版音樂，好開心，於是上Google，發現真係有Google音樂下載！但呢個試聽同下載服務僅對中國大陸境內提供。&lt;/p&gt;
&lt;p&gt;但係好失望，我一點下載就彈出個網頁話 “403 forbidden”，頂！我本來就係大陸境內，冇理由唔得咖？！開始我以為係瀏覽器嘅安全選項問題，於是我將D防火牆啊、安全選項啊全部關晒，但係都唔得，搞左幾日，上網抄左幾日都冇見到有講呢個問題，無法子啦，只好唔搞~~&lt;/p&gt;
&lt;p&gt;後尾翻到公司，啱好見到個同事用Google音樂聽緊歌，我以為係公司可以，於是嗱嗱臨開機試下，點知又係唔得，甘就出奇啦，我地公司係用一個IP出口嘅，冇理由，佢得我唔得咖？！於是我比較左下我台機同同事台機有乜唔同，比較之下先發現，佢個DNS同我個DNS唔一樣，改左個DNS之後，掂晒！！終於可以下載啦！&lt;/p&gt;
&lt;p&gt;因為我用開嘅係 OpenDNS，所以所有我用嘅機都會設置個DNS為OpenDNS 嘅地址，估計係中國境內 Google 音樂下載網址解釋僅對中國境內DNS有效，所以在國際DNS服務器內解釋呢個地址到其它位置，於是通過OpenDNS解釋到其它嘅IP導致出現 forbidden 嘅現象。&lt;/p&gt;
</summary></entry><entry><title>點解要點解?</title><link href="https://starofrainnight.github.io/cht/dian-jie-yao-dian-jie.html" rel="alternate"></link><updated>2009-04-05T10:05:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2009-04-05:cht/dian-jie-yao-dian-jie.html</id><summary type="html">&lt;p&gt;　　記得係大學果陣，有一次有個課程設計要做一個C語言嘅詞法解釋器。&lt;/p&gt;
&lt;p&gt;　　果陣起左個念頭想做一個通用嘅語言編譯器，即係一個萬能既語言編譯器，類似於C語言編譯器、Pascal編譯器等等，但係唔需要硬性為每個語言寫程式（GCC就係呢類型嘅實作），只需要寫一個簡單嘅詞法語法配置文本文檔即可以支持編譯出不同平台嘅程式（二進制文件格式）。&lt;/p&gt;
&lt;p&gt;　　後來同老師講左下自己嘅諗法同埋一D唔成熟嘅思路，同埋打算用幾十年時間嚟做呢樣嘢。&lt;/p&gt;
&lt;p&gt;　　老師同我講（大概意思）：「呢種編譯器到目前都未出現，起碼證明呢樣嘢難度好高或者幾乎唔可能實現，點解要做呢D無用功呢？何況你做咗出嚟，佢又有乜價值呢？又有乜市場呢？何況做通用嘅編譯器你嘅編譯速度就自然比特定嘅編譯器速度慢，甘你呢個編譯器又有乜用呢？」&lt;/p&gt;
&lt;p&gt;　　聽到老師甘講，有D愕然，講真啦，老師講得係啱，但係……我只係想做呢樣嘢，無話想攞佢嚟用，只係想做，點解一定要有用、一定要有價值、一定要有市場啫？就好似細路嘅玩具咁，只係因為有興趣，想玩就玩啫，當時亦係甘回答嘅。&lt;/p&gt;
&lt;p&gt;　　人嘅一生，短短百年，雖則現實一分錢可以逼死英雄漢，但我覺得人一世物一世，樣樣事情都講錢、講有用、講意義未免太無意思啦，更有意思嘅事情例如靜靜的聽一首歌、諗辦法實現一個自己諗法嘅程式、嘗試一個月坐看夕陽西下、學習一下道家無為之法……人死如燈滅，生前嘅一切名聲、金錢、榮譽、利欲終將歸於塵土，千百年後或許無人知道你、或許有人知道你，又如何？一切不過碌碌，重不如趁住生命尚存做D自己鍾意嘅事情。遊戲人間亦係個唔錯的人生態度。&lt;/p&gt;
&lt;p&gt;　　好彩一直堅持自己選擇自己嘅道路，而家做嘅係自己喜歡嘅編程工作，雖然唔係做自己最鍾意嘅遊戲引擎，但只要係寫程式我就好開心啦，何況而家通常寫嘅系嵌入式程式同埋驅動程式，都系自己鍾意做嘅部分，而家好開心~~~&lt;/p&gt;
</summary></entry><entry><title>Linux or ReactOS ?</title><link href="https://starofrainnight.github.io/cht/linux-or-reactos.html" rel="alternate"></link><updated>2009-02-09T01:12:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2009-02-09:cht/linux-or-reactos.html</id><summary type="html">&lt;p&gt;　　用左 Linux 嚟做開發有一段時間，慢慢發覺，Linux 原來面對嘅用戶群應該喺程式撰寫員先至啱 =_=b&lt;/p&gt;
&lt;p&gt;　　剛開始用 Ubuntu 時，諗住佢好似 Windows 咁樣好容易上手嘅，點知到喺使用嘅過程中遇到好多奇奇怪怪嘅問題，Google 之後，先知道又翻到石器時代，大多數問題唔可以通過 GUI 嚟解決，基本上呢D問題都要直接喺命令行底下解決，或者需要從某D源代碼重新編譯安裝，慢慢咁，到最後，習慣左連GUI都唔用，只用命令行。講真啦，都喺鍾意乜嘢都用鼠標喺各個GUI裡面跳來跳去呢種直觀嘅方式嚟解決問題 -_-|||&lt;/p&gt;
&lt;p&gt;　　直到上年年尾，發現左一個好玩嘅 OS —— ReactOS，佢哋既目標似乎喺要做一個開源板嘅 Windows NT 內核 OS！哇哈哈，全部繼承左 Windows 系列嘅操作方式，而且完全兼容 Windows NT 及以上 OS 嘅軟體同埋驅動程式！！特別喺驅動程式，雖然話有唔少硬體開始有 Linux 嘅驅動程式并且有成班人喺喥開發支持舊硬體嘅驅動程式，但仲喺有唔少廠商為左方便只開發 Windows 平台嘅驅動程式，咁樣如果你買左果D硬體，你焗住只能喺 Windows 下用啦。&lt;/p&gt;
&lt;p&gt;　　下載左個 ReactOS 嚟玩左一下，發覺佢已經可以跑起身，同個 Windows 2000 好鬼似。可以開一D類似於 FireFox 2.0 之類嘅軟件，只喺佢仲處於非常唔穩定嘅開發程度，經常郁下就死機藍屏。不過佢哋嘅開發進度好快，睇左下，平均每日有成十個修改提交，唔知幾時可以真正進入實用嘅階段呢，真喺好期待！&lt;/p&gt;
&lt;p&gt;　　比較 Linux 同埋 ReactOS，我覺得 ReactOS 嘅理念會更有前景，畢竟好多公司或者家庭購買左嘅軟體硬體都只能用喺 Windows 上，如果可以直接轉到呢個 ReactOS 上，買左新機後，就可以慳翻筆買 OS 嘅錢，畢竟叫個個都轉到 Linux 底下確實系有難度，特別喺遇著好似我大姐夫D甘嘅人，用 Windows 只會點鼠標，又唔願學新嘢，叫佢去用 Linux 估計同儸佢條命差唔多……&lt;/p&gt;
&lt;p&gt;　　Linux？唉，如果界面嘅易用性同埋速度可以提高上去，估計可以搶到 Windows 平台部分做開發嘅人員、願意嚐新的人同埋打算慳成本而進行平台轉換嘅團體。&lt;/p&gt;
</summary></entry><entry><title>啓明星</title><link href="https://starofrainnight.github.io/cht/qi-ming-xing.html" rel="alternate"></link><updated>2008-10-12T23:37:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-10-12:cht/qi-ming-xing.html</id><summary type="html">&lt;p&gt;今日瀏覽網頁，無意中查左下啓明星，先知道，原來啓明星即系金星，亦系古時所講既「太白」或者「長庚」。傍晚出現時就稱之為「長庚」，清晨出現時稱「啟明」。其它既稱呼仲有：殷星，大正，營星，明星，觀星，大衣，大威，太（白＋皋），終星，大相，大囂，爽星，太皓，序星。&lt;/p&gt;
&lt;p&gt;可以通過維基百科查詢到更詳細的 &lt;a class="reference external" href="http://zh.wikipedia.org/w/index.php?title=%E9%87%91%E6%98%9F&amp;amp;variant=zh-hk"&gt;金星資料&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>MinGW 下 編譯 wxSQLite</title><link href="https://starofrainnight.github.io/cht/mingw-xia-bian-yi-wxsqlite.html" rel="alternate"></link><updated>2008-06-23T15:44:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-06-23:cht/mingw-xia-bian-yi-wxsqlite.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;初始條件&lt;/h2&gt;
&lt;p&gt;首先確定環境變量只有 Mingw 的路徑而沒有 msys 的路徑，因為使用 msys 編譯會有些問題。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="makefile"&gt;
&lt;h2&gt;修改 makefile&lt;/h2&gt;
&lt;p&gt;打開 wxsqlite3build 下的 makefile.gcc，設定你需要的條件，如若妳不需要加密模塊並且擁有自己的SQLite3源代碼目錄，妳可以設定 SQLITE3_DIR&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;編譯&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
make -f makefile.gcc clean
make -f makefile.gcc
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="wxsqlite"></category><category term="mingw"></category></entry><entry><title>分佈式版本控制系統SVK搭配TortoiseSVN的使用</title><link href="https://starofrainnight.github.io/cht/fen-bu-shi-ban-ben-kong-zhi-xi-tong-svkda-pei-tortoisesvnde-shi-yong.html" rel="alternate"></link><updated>2008-06-19T23:27:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-06-19:cht/fen-bu-shi-ban-ben-kong-zhi-xi-tong-svkda-pei-tortoisesvnde-shi-yong.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;SVK與Linus所開發的Git相似，是一種分布式的版本控制系統，但它並不是完全從頭編寫的版本控制系統，而是基于 Subversion 的分布式的版本控制系统。如 CVS，Subversion 這些集中式管理系统存在对唯一的版本库过分依赖的缺陷：一旦不能正常连接到集中式的版本库，整个系统陷入瘫痪。分布式的版本控制系統最大的好處在于可以维护分布式的版本库，分散的开发人员可以通过 SVK 建立远程的 CVS，Subversion，P4 协议的版本库镜像，选择工作在自己合适的镜像版本库，这个镜像甚至可以是本地的，整个工作可以离线进行，然后在需要的时候同步镜像版本库到主版本库。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;假定條件&lt;/h2&gt;
&lt;p&gt;首先假定妳已經熟悉所有SVN的操作,
再假定 c:\svnlib 為SVN的對外的倉庫根目錄,
假定妳機子已經安裝好SVN服務,
若 c:\svnlib 下有一項目 test 倉庫(c:\svnlib\test), 假定妳能正確通過Tortoise讀寫其項目文件( svn://localhost/test ),
假定網絡版本庫為 svn://192.168.1.100/MyProject.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;初始化&lt;/h2&gt;
&lt;p&gt;在 c:\svnlib 下創建目錄 svklib (目錄名隨便你定義)
在 c:\svnlib\svklib 使用 TortoiseSVN 右鍵在此創建版本庫（注意：這一步是鏡像的基礎！因為SVK用的就是SVN的版本庫）&lt;/p&gt;
&lt;p&gt;SVK是默認在 &amp;quot;C:\Documents and Settings\當前用戶名\.svk\Local&amp;quot; 創建鏡像倉庫的，所以需要先把鏡像倉庫位置重定位到你需要的位置( 當然, 如果妳喜歡默認的位置, 那你可以跳過這一步 )&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk depotmap --relocate // c:\\svnlib\\svklib
&lt;/pre&gt;
&lt;p&gt;上面這行命令有一個概念, 就是depot-map -- 倉庫表, 妳可以使用svk depotmap 建立多個鏡像倉庫, 而不重定位, 這裡為了方便解說並盡量減少旁枝末節的繁雜概念問題而直接把默認位置重定位了. &amp;quot;//&amp;quot; 是一個倉庫名, 類似於Linux的那個根目錄, SVK把默認路徑當作根目錄, 所有的鏡像倉庫均建立在根目錄以上.&lt;/p&gt;
&lt;p&gt;妳用 svk depotmap --list 命令就可以看到SVK的根目錄被定位到 c:\svnlib\svklib 下了&lt;/p&gt;
&lt;p&gt;接下來我們建立一個鏡像目錄.
我們必須建立一個鏡像目錄, 因為所有提交到此鏡像目錄的操作均被認為提交到網絡上的原始版本庫!!!&lt;/p&gt;
&lt;p&gt;下面這裡的 &amp;quot;-m test&amp;quot; 是設定此次操作的提交註釋，具體的詳情請參考SVK的幫助。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk mkdir //mirror -m test
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;日常使用&lt;/h2&gt;
&lt;p&gt;镜像! 把網絡版本庫鏡像下來.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk mirror svn://192.168.1.100/MyProject //mirror/MyProject
&lt;/pre&gt;
&lt;p&gt;同步! 注意: 這裡不需要再輸入那個網絡路徑了, 網絡路徑在上面進行鏡像時會記錄下來的!&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk sync //mirror/MyProject
&lt;/pre&gt;
&lt;p&gt;成功!&lt;/p&gt;
&lt;p&gt;由於對鏡像目錄進行修改即相當於直接提交到網絡版本庫, 因此不能直接對鏡像版本庫進行修改, 所以必須新建一個本地的挎貝(分枝)! 注意!! 是必須!!&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk mkdir //local
svk cp //mirror/MyProject //local/MyProject
&lt;/pre&gt;
&lt;p&gt;接下來妳就可以使用TortoiseSVN的功能方便地對你剛才分枝下來的版本(//local/MyProject 即 svn://localhost/svklib/local/MyProject )進行取出、修改、提交了
只是要記住, 妳所做的一切操作只能是修改妳的本地分枝, 即 SVK 源代碼目錄下面那個 Local 下的 MyProject!&lt;/p&gt;
&lt;p&gt;當妳需要把修改提交到網絡原始數據庫時, 妳需要先更新鏡像目錄&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk sync //mirror/MyProject
&lt;/pre&gt;
&lt;p&gt;再提交妳的代碼，此過程會自動 Merge 妳的修改到遠程版本庫。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svk push //local/MyProject
&lt;/pre&gt;
&lt;p&gt;記得, 修改鏡像庫時, 必須且只能使用SVK的方法, 否則更新不能被更新到網絡版本庫!&lt;/p&gt;
&lt;p&gt;各種關係及操作如下圖：&lt;/p&gt;
&lt;img alt="" src="https://starofrainnight.github.io/cht/images/usingsvk.jpg" /&gt;
&lt;/div&gt;
</summary><category term="svk"></category><category term="svn"></category><category term="tortoisesvn"></category></entry><entry><title>MinGW 下編譯 gettext 0.17</title><link href="https://starofrainnight.github.io/cht/mingw-xia-bian-yi-gettext-017.html" rel="alternate"></link><updated>2008-06-17T07:33:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-06-17:cht/mingw-xia-bian-yi-gettext-017.html</id><summary type="html">&lt;p&gt;這兩天編譯gettext搞得焦頭爛額，機子裡裝了大量的開源工具，結果各種動態鏈接庫版本不一致，編譯工具不一致，導致編譯時老是不成功，後來乾脆寫個批處理，把 path 環境變量只設置為 mingw 及 msys 的Bin，把 include 中除 mingw 及 msys的路徑外（例如Gtk）全刪除，然後在Dos下使用以下的編譯命令一次編譯成功：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sh ./configure --enable-threads=win32 --with-libiconv-prefix=d:/sb/sdks/libiconv
&lt;/pre&gt;
&lt;p&gt;當前使用到的編譯環境變量(Mingw GCC4.21)：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
CPPFLAGS=-mno-cygwin -Wall -pipe -mthreads -fno-strict-aliasing
CFLAGS=-mno-cygwin -O2 -g -pipe -mthreads -fno-strict-aliasing
CXXFLAGS=-mno-cygwin -O2 -g -pipe -mthreads -fno-strict-aliasing
LDFLAG=-mno-cygwin
&lt;/pre&gt;
</summary><category term="mingw"></category></entry><entry><title>使用 OTL 連接 SQLite</title><link href="https://starofrainnight.github.io/cht/shi-yong-otl-lian-jie-sqlite.html" rel="alternate"></link><updated>2008-06-14T13:56:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-06-14:cht/shi-yong-otl-lian-jie-sqlite.html</id><summary type="html">&lt;p&gt;本文章假定妳熟悉SQLite數據庫，假定妳對OTL有 一定了解，假定妳所使用的操作系統為Windows平台。&lt;/p&gt;
&lt;p&gt;OTL 採用的是ODBC數據源機制，到 &lt;a class="reference external" href="http://www.ch-werner.de/sqliteodbc/"&gt;http://www.ch-werner.de/sqliteodbc/&lt;/a&gt; 可下載到最新的SQLiteODBC數據源驅動。&lt;/p&gt;
&lt;p&gt;假定你已經創建了一個名為 MyTestDB 的數據源連接到你的數據庫，數據庫中有一表 Users, 表中有字段 id 及 value，id 为整型，value為字符串50個字節。&lt;/p&gt;
&lt;p&gt;代碼：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

#define OTL_ODBC
#include &amp;lt;otlv4.h&amp;gt;

otl_connect db; // Database connection

void test_select( void )
{

　　otl_stream dbstream( 1 , &amp;quot; select * from Users &amp;quot; , db );
　　int　　　　　Usersid;
　　char　　　　 Usersvalue[ 50 ] = &amp;quot;&amp;quot; ;

　　while ( !dbstream.eof() )
　　{
　　　　dbstream &amp;gt;&amp;gt; Usersid &amp;gt;&amp;gt; Usersvalue;
　　　　std::cout
　　　　　　&amp;lt;&amp;lt; &amp;quot;Users.id : &amp;quot; &amp;lt;&amp;lt; Usersid
　　　　　　&amp;lt;&amp;lt; &amp;quot;Users.value : &amp;quot; &amp;lt;&amp;lt; Usersvalue &amp;lt;&amp;lt; std::endl;
　　}
}

int main()
{
　　otl_connect::otl_initialize();

　　db.rlogon( &amp;quot;DSN=MyTestDB&amp;quot; );
　　if ( db.connected )
　　{
　　　　test_select();
　　}
　　db.logoff();

　　system( &amp;quot;PAUSE&amp;quot; );
　　return 0 ;
}
&lt;/pre&gt;
</summary><category term="otl"></category><category term="sqlite"></category></entry><entry><title>數據包在互聯網</title><link href="https://starofrainnight.github.io/cht/shu-ju-bao-zai-hu-lian-wang.html" rel="alternate"></link><updated>2008-06-13T12:38:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-06-13:cht/shu-ju-bao-zai-hu-lian-wang.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;1&amp;nbsp;&amp;nbsp;&amp;nbsp;前言&lt;/h2&gt;
&lt;p&gt;前段時間做一個NDIS網絡驅動，功能是修改IP包的IP地址并傳送到指定的機器，在測試時發現一個問題，假如在內網中傳送數據包到在內網的一台不同網域的機器上，數據包不能傳達，具體問題在[1]有詳細說明。在 Google查了很多數據，經過多次測試，最終發覺，原來是路由器（Router）的問題。在這過程中，發現很多網友對數據包在網絡上的傳輸有誤解，因此我想對這個問題進行一次詳細的說明，以備以后的不時之需。&lt;/p&gt;
&lt;p&gt;網上有很多網友對以太網的理解是：數據包在互聯網是在IP層傳輸的，以IP地址來判斷地址并傳輸的。這是一個誤解，互聯網不認識IP協議層，只是由於現在有些寬帶運營商（ISP）使用了“釆用執行在協議層的路由器”，所以導致出現由於 IP不在該路由器所控制的范圍則自動被放棄，我們看見的就是不符合IP協議的均會被放棄。這種做法好處是避免了廣播風暴問題，但同時又削弱了互聯網的功能，例如我們就不能直接把一個不釆用IP協議的數據包傳輸至互聯網某一個物理地址（MAC地址，下同）的機器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;2&amp;nbsp;&amp;nbsp;&amp;nbsp;互聯網&lt;/h2&gt;
&lt;p&gt;當前互聯網釆用的是以太網，即釆用以太網交換機實現的，這種網絡的好處是，只要你知道網絡上某一機器的物理地址，即可以把數據包通過廣播傳輸到相應的機器上，但同時這樣也會造成廣播風暴，致使網絡癱瘓，當然這種情況是可以通過某些手段進行抑制的，下面會進一步說明。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;以太交換機&lt;/h3&gt;
&lt;p&gt;為了簡化模模型，我們先假設所有機器均以獨立IP連接到互聯網。（如圖）&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://starofrainnight.github.io/cht/images/data-on-network.png" /&gt;
&lt;p&gt;以太網交換機處於的是數據鏈路層，它只處理以太網頭，也就是說它只認識數據包的物理地址，舊式的交換機的處理過程是：只要數據包在互聯網某一個點發出數據包，數據包在經過每一個交換機時，交換機自動把數據包向所有端口廣播，這樣，通過一個又一個交換機的廣播，終端機的機器判斷該數據包的物理地址是否自身的物理地址，是就通知上層數據包的到達，否則直接掉棄。這種處理方法，在小數據量時很有效，但當有大量數據傳輸時，就難以保證了，由於交換機不停地廣播數據包，就會致使網絡由於廣播的數據太多而癱瘓。這時人們就想出了辦法，就是物理地址查詢機制：每一個從交換機輸入端的經過的數據包源物理地址將被存儲起來，然后當有數據包來臨時，就向每個端口查詢是否存在該數據包的目的物理地址，如果存在，則直接把數據包傳送往該端口，如果都尋找不到，則廣播該數據包。這樣就有效地抑制了大部分的數據包廣播了。&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;2.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;優點&lt;/h4&gt;
&lt;div class="section" id="id5"&gt;
&lt;h5&gt;2.1.1.1&amp;nbsp;&amp;nbsp;&amp;nbsp;增加協議靈活性&lt;/h5&gt;
&lt;p&gt;例如你需要設計一個不使用IP協議的嵌入式設備，有人可能會說為什么不釆用IP協議？IP協議有更成熟的技朮，以及現成的各種函數例程。只要是做過工控、嵌入式設備、智能家居設備、寫過５１程序或者是在DOS時代做過程序都知道，有大部分的項目對內存及空間的要求是非常嚴格的，其內存是寸金尺土，少几個字節就能換來整個產品成本下降數千元以至更多，通常一些嵌入式設備，需要的控制指令是很短的，只需要几個字節就足矣，沒必要攜帶龐大的IP頭。而且在互聯網上通過物理地址即可以把數據包傳輸到指定的設備，IP地址也就沒必要了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h5&gt;2.1.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;准確到達目的地&lt;/h5&gt;
&lt;p&gt;由以太交換網的結構及處理方式我們可以知道，數據包是可以通過物理地址直接到達目的地的，這也是為什麼有些技術書籍寫的可以通過數據包獲取源目的地物理地址的原理。物理地址類似於IP地址，IP地址代表的是互聯網上一個虛擬機器，而物理地址代表的是互聯網上一個實際設備，IP地址只有4位字節，而我們平常使用的物理地址是6位字節，擁有 281474976710656（281萬億）個地址，比起IP地址多多了，從當前情況來看，足夠各種計算機及設備都配備一個物理地址的，暫時也不需要擔心類似IP地址那樣的地址不夠問題。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h4&gt;2.1.2&amp;nbsp;&amp;nbsp;&amp;nbsp;缺點&lt;/h4&gt;
&lt;div class="section" id="id8"&gt;
&lt;h5&gt;2.1.2.1&amp;nbsp;&amp;nbsp;&amp;nbsp;沒有更多的控制參數&lt;/h5&gt;
&lt;p&gt;以太網協議頭只有兩個物理地址及一個后續協議（或長度）參數。此缺點可以通過自定上層協議來實現更精細的控制要求來解決。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h5&gt;2.1.2.2&amp;nbsp;&amp;nbsp;&amp;nbsp;容易造成廣播風暴&lt;/h5&gt;
&lt;p&gt;由於數據包釆用廣播來進行數據包傳輸，因此當各處傳送的數據包量大時，會導致網絡崩潰。此缺點可以釆用物理地址查詢機制來抑制。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4&gt;2.1.3&amp;nbsp;&amp;nbsp;&amp;nbsp;路由器&lt;/h4&gt;
&lt;p&gt;一些公司租用一倏寬帶后，希望能物盡其用，通常會把全公司的機器都搭上互聯網這趟快車，這時候就有几種方案：１、集線器；２、交換機；３、路由器。我們看下三種方案的優缺點：首先是集線器，嗯，這個方案效率有點低，當多個端口同時出現傳送或接收數據時，只能喊“My God”了，因此此方案不予釆用。剩下的兩個方案，各有各優點，只能見仁見智了，在出口IP不限制出口物理地址時，推荐釆用交換機以換取更大自由度否則就釆用路由器吧。&lt;/p&gt;
&lt;p&gt;路由器實際上跟以太網交換非常相似，只是功能更復雜了。路由器會自動根據網絡拓撲、負荷的改變及時維護該路由表，并擁有更強大的數據管理功能，例如防火牆、流量控制、自動撥號等，當然現在交換機也有這些功能的了，所以交換機跟路由器的功能很多時候重復了。當路由器找不到某一端口輸入的數據包對應的輸出端口時，即刪除該包。注意，這一點它跟交換機是不一樣的，交換機找不到時即廣播該數據包，因此，如果有一設備在路由器控制范圍內，而路由器不知道的話，那么該數據不會到達該設備！雖然路由器極好地抑制了數據包的廣播，但同時也損失了數據包到達准確地址的機會。&lt;/p&gt;
&lt;p&gt;同時，由於中國人口太多，過多的人口，過少的接入IP，導致網絡的發展畸形化，現在國內大部分中小規模路由器直接釆用了IP協議控制！！這一點導致了所有非IP協議數據包不能傳送！而且，就算明知道路由器控制的網域存在相應的物理地址，只要IP地址不對應，它也不進行傳送，結果可想而知，嵌入式設備這類就必須釆用 IP協議了，由此也帶來了設備成本的提高。釆用了IP協議，還可通過透明橋接來解決廣播技朮問題。但如果像我所釆用的那款路由器就慘了，它還把進出的數據包物理地址給修改了，這樣，內外就不能進行正常的UDP或者其它協議的數據傳輸了，只能通過中轉形式，如再買一倏電信或網通的寬帶，接一台計算機作中轉站，服務器長期維護一倏中轉站的TCP連接，然后所有外來數據均通過中轉站打包，傳送往服務器，再在服務器解包，再轉發相應端口。當然，這種修改數據包物理地址的方案，估計是為了針對現在寬帶運營商出現的封路由器而設計的，也是迫於無奈啊。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h2&gt;3&amp;nbsp;&amp;nbsp;&amp;nbsp;溫情提示&lt;/h2&gt;
&lt;p&gt;在國內，建議采用電信或網通的互聯網服務，目前就我所知，只有電信和網通是能讓你機子直接擁有公網IP的，雖然是動態的，也比其它的ISP如鐵通、視通等的內網 IP好，例如我使用的鐵通（後悔！），別人就不能根據我的出口IP直接連接到我的機子，也就是說我付的費用跟電信和網通一樣，但我卻只能擁有一半的功能，只能出不能進，如果需要外網能訪問我的機子，需要付一大筆的費用，很不划算。鐵通、視通這些是租用電信和網通的IP，然後采用分級路由器建立了一個龐大的局域網，因此所有出去的數據包的物理地址和進來的數據包的源物理地址均被修改為路由器的物理地址，也由於物理地址被修改，互聯網上別的設備或機器就不能通過物理地址定位我們的機子！同時由於路由器內網全部采用內網地址，因此只有鐵通或視通他們內部網的并用處於同一路由器級的用戶才能直接訪問相互的機子，其實就是局域網互訪，而因特網用戶是不能訪問你的機子的！當然，如果你不需要建立自己的網站、不需要別人訪問自己的機子、不需要建立自己的服務器的話，你家裡也沒有采用因特網的智能家居之類的嵌入式設備，這樣，鐵通、視通的安全性卻反而比電信和網通高，因為你不在公網內，被局域網保護起來了，特別是路由器有防火牆的情況下。如若你只能使用鐵通，那也不是沒辦法使你的機子公開的，只是方法就複雜多了，還需要一筆額外的費用，而且速度和穩定性沒有保障，那就是采用花生米的服務了。其實就是做了一個NAT轉換，或者是數據包的轉發，在這情況下，你的機子需要一直開著一個TCP連接，以維持數據的傳送。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;4&amp;nbsp;&amp;nbsp;&amp;nbsp;參考&lt;/h2&gt;
&lt;p&gt;(1) 偽IP如何實現與客戶機進行TCP通訊？
&lt;a class="reference external" href="http://starofrainnight.blogspot.com/2008/04/iptcp.html"&gt;http://starofrainnight.blogspot.com/2008/04/iptcp.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="network"></category></entry><entry><title>偽IP如何實現與客戶機進行TCP通訊？</title><link href="https://starofrainnight.github.io/cht/wei-ipru-he-shi-xian-yu-ke-hu-ji-jin-xing-tcptong-xun.html" rel="alternate"></link><updated>2008-04-05T11:38:00+08:00</updated><author><name>starofrainnight</name></author><id>tag:starofrainnight.github.io,2008-04-05:cht/wei-ipru-he-shi-xian-yu-ke-hu-ji-jin-xing-tcptong-xun.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;軟件環境&lt;/h2&gt;
&lt;p&gt;WinXP SP2&lt;/p&gt;
&lt;p&gt;截取數據包的Ndis5.0驅動已經寫好。
在用戶層，能夠修改驅動發來的數據包的IP地址，客戶機也能接收到該數據包。&lt;/p&gt;
&lt;p&gt;我這個軟件是用于模擬多客戶機與服務器連接實現數據傳輸的測試軟件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;硬件環境&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
(33.33.33.33(假定是這個))　　     　 |—— 客戶機2 (192.168.1.105)
客戶機１——路由 (192.168.1.1)——|
   　　　　　　　　　　　　　　　 |—— 發送機 (192.168.1.100) （偽裝 99.99.99.99）
&lt;/pre&gt;
&lt;p&gt;現在需要發送機偽裝IP 99.99.99.99 與兩客戶機進行TCP通信&lt;/p&gt;
&lt;p&gt;在客戶機2安裝的Ethereal 檢測到發送機發來的IP為 99.99.99.99 數據包，物理地址（MAC）也為發送機的物理地址。&lt;/p&gt;
&lt;p&gt;但 問題是，當客戶機2接收到第一次TCP握手包后，它返回的響應包雖然目的IP地址仍然是99.99.99.99，但物理地址卻是網關 192.168.1.1的物理地址！我再查看客戶機2的數據包，發現在它接收到發送機發送的握手包時，它先發送ARP數據包查詢了網關 （192.168.1.1）的物理地址再發到網關。也就是說，當客戶機發現接收的數據包IP與自己不在同一子域則自動把數據包發往網關，但現在問題是由于 發送的物理地址改變了，網關只能查詢正確的99.99.99.99的物理地址，那這時候，數據包也就不能再返回偽裝的發送機上了。于是TCP連接被逼中 斷。&lt;/p&gt;
&lt;p&gt;而且，兩客戶機均開啟了防火牆，不能使用ICMP實現數據包路徑轉移。&lt;/p&gt;
&lt;p&gt;我嘗試發送ARP包去修改客戶機2的ARP緩沖，但沒用，不同一子域的IP地址不會受到緩沖，結果IP包依然發往網關。&lt;/p&gt;
&lt;p&gt;有何方法可以實現發送機與兩客戶機用偽IP通信？鬱悶中……&lt;/p&gt;
&lt;/div&gt;
</summary><category term="ndis"></category></entry></feed>